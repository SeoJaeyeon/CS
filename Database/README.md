### Database

---

**목차**

- [데이터베이스의 정의](#데이터베이스의-정의)
- [DBMS vs 파일시스템](#dbms)
- [데이터 정규화](#데이터-정규화)
- [데이터베이스의 성능](#데이터베이스의-성능)
- [인덱스](#인덱스)
- [트랜잭션](#트랜잭션)
- [보안 및 무결성](#보안-및-무결성)
- [병행제어](#병행제어)
- [SQL](sql)
- [NoSQL](#nosql)

---

### 데이터베이스의 정의

---

- 응용 시스템들이 데이터를 공유할 수 있도록 모든 데이터를 통합하여 저장한 데이터 
- Shared Data, Operational Data, Integrated Data, Stored Data



### 데이터베이스의 특징

- 데이터 중복의 최소화
- 계속적인 변화: 항상 최신의 데이터 유지
- 실시간 접근
- 동시 공유
- 내용에 의한 접근: 저장되어 있는 데이터가 주소가 아닌 내용에 의해 참조될 수 있음
- 뛰어난 자료 간 연계성: 개체 사이의 관계성이 저장됨



### DBMS(Database Management System)

---

- 운영체제 위에서 작동하며 데이터베이스의 생성과 조작을 담당하는 소프트웨어 시스템

**DBMS의 특징**

- 데이터 중복의 최소화 -> 파일시스템의 단점
- 데이터 공유 
- 데이터 표준화
- 데이터 보안성 -> 계정 관리 또는 접근 권한 설정
- 데이터 무결성 -> 데이터의 유효성 검사를 통해 잘못된 데이터를 방지
- 데이터 일관성 -> 연관된 정보를 논리적 구조로 관리함으로 써, 데이터의 불일치성 배제



**파일시스템 vs DBMS**

- 데이터의 종속성: 파일 시스템은 하나의 데이터 구조를 하나의 응용 프로그램이 독립적으로 관리하기 때문에, 데이터 구조를 변경할 때 그 응용 프로그램도 변경해야하는 단점이 있다. 하지만 DBMS에서는 프로그램과 데이터가 독립되어있기 때문에 이러한 문제점을 피할 수 있다.
- 데이터의 중복성: 파일 시스템은 같은 내용이더라도 구조가 다르면 중복되어 저장되기 때문에, 데이터의 일관성, 무결성, 보안에 좋지 않다. DBMS는 데이터를 통합해서 관리함으로써 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.



### 데이터 정규화

---

**이상(Anomaly) 현상**

데이터의 중복으로 인해 발생하는 이상현상 

- 삭제 이상: 임의의 튜플 삭제 시 그 튜플과 관계를 가지고 있던 관계성도 함께 삭제되는 현상
- 삽입 이상: 삽입 의도가 없는 관계도 삽입되는 현상(Null)
- 갱신 이상: 임의의 데이터를 갱신했을 때, 관계를 형성하던 다른 튜플과의 일관성이 깨지는 현상 



**함수 종속(FD: Functional Dependency)**

어떤 릴레이션 R에서 A, B가 릴레이션 R의 부분 속성이라고 할 때, 속성 A의 도메인 값 각각에 대해 속성 B의 도메인 값이 오직 한 개만 연관 된 경우 B는 A의 함수 종속이라고 하며, A -> B 라고 표현한다. A는 결정자, B는 종속자라고 한다. 



**정규화**

이상 현상이 발생하지 않도록 하나의 릴레이션에 하나의 의미만 존재하게 릴레이션을 분해하는 과정 

- 제 1정규형: 어떤 릴레이션 R에 속한 모든 도메인이 **원자 값**으로만 되어 있음
- 제 2정규형: 어떤 릴레이션 R이 제 1정규형에 속하고, 기본키에 속하지 않는 모든 속성이 기본키에 **완전 함수적 종속** 

- 제 3정규형: 어떤 릴레이션 R이 제 2정규형이면서, 기본키에 속하지 않는 모든 속성이 기본키에 **이행적 함수 종속이 아닌 경우**
- 보이스 코드 정규형(Boyce-Codd Normal Form: BCNF): 릴레이션 R의 모든 결정자가 후보키
- 제 4정규형: 릴레이션 R에서 A에 다중치 종속인 B가 존재할 때, R의 모든 속성도 A에 함수 종속 
- 제 5정규형: 릴레이션 R에 존재하는 모든 조인 종속이 릴레이션 R의 후보키를 통해서만 성립되는 경우



### 데이터베이스의 성능

---

출처 - https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database

데이터베이스의 성능 이슈는 디스크 I/O 를 어떻게 줄이느냐에서 시작된다. 디스크 I/O 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.

그렇기 때문에 순차 I/O 가 랜덤 I/O 보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O 이다. 랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.



### 인덱스

---

**인덱스(Index)**

신속한 검색을 위해 데이터의 위치 정보를 모아놓은 것으로 책에서 목차에 해당

- DBMS에서 칼럼의 값과 해당 레코드가 저장된 주소를 K-V 쌍의 인덱스로 만들어둔다.
- 항상 정렬된 상태를 유지하기 때문에 검색은 빠르지만, 삽입, 삭제 연산의 속도는 느리다.



**인덱스 자료구조**

- B-트리: 모든 인덱스 값이 실제 데이터를 가리키도록 구성되어 있으며 탐색 시 중위순회 한다. 한 노드 안에 있는 키 값은 오름차순 정렬되어있으며, 키 값의 삽입 삭제 시 자동으로 합병이나 분할이 이루어진다.
- B+-트리: 인덱스 세트와 순차 세트로 구성하여 인덱스 세트는 리프노드를 찾아갈 수 있는 키, 포인터만 제공하고, 리프 노드에 모든 데이터가 나타나도록 하여 **리프 노드만으로도 모든 데이터를 탐색할 수 있도록 한 구조**이다. 리프노드는 순차 세트를 나타내며 모두 리스트로 연결되어 있고 정렬되어있다. 대부분의 DBMS가 B+-트리 인덱스를 사용한다.
- Red-Black Tree: 각각의 노드가 레드나 블랙인 색상 속성을 가지고 있는 **이진 탐색 트리**로, 자료의 삽입과 삭제, 검색에서 최악의 경우에도 **일정한 실행 시간을 보장** (worst-case guarantees)한다. 루트 노드부터 가장 먼 경로까지의 거리가, 가장 가까운 경로까지의 거리의 두 배 보다 항상 작은 것이 특징이다.
- 클러스터드 인덱스: **프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것**을 클러스터드 인덱스라고 표현한다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다(정렬 유지). 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야 한다.**클러스터드 인덱스는 테이블 당 한 개만 생성**할 수 있다. 
- 논-클러스터드 인덱스: 클러스터드 인덱스와 다르게 물리적으로 행을 재배열하지 않는다. 또, 1개 이상으로 생성할 수 있다. 별도의 인덱스 테이블을 생성하여 정렬하는 방식으로 컬럼을 찾는다. 



### 트랜잭션

---

**트랜잭션의 정의**

작업의 완전성을 보장하기 위해 논리적인 작업 셋을 모두 처리하거나, 모두 처리하지 않는 기능



**트랜잭션의 특성(ACID)**

- 원자성(Atomicity)
- 일관성(Consistency): 트랜잭션 실행 후에도 데이터베이스는 무결성이 유지되어야 함
- 독립성(Isolation): 트랜잭션 실행 중 다른 트랜잭션이 침범하지 못함
- 역속성(Durability): 트랜잭션에 의해 변화된 상태는 계속 유지될 수 있어야 함 



**트랜잭션의 연산**

- COMMIT: 트랜잭션의 실행이 성공적으로 종료됨. 영속성과 일관성이 보장된 상태.
- ROLLBACK: 트랜잭션이 실패하고 원래의 상태로 복귀시켜야 하는 상태 



**트랜잭션의 격리수준**

- Serializable
- Repeatable Read
- Read Committed
- Read Uncommitted

### 보안 및 무결성

---

**보안**

외부의 부적절한 접근으로부터 보호하는 것으로 관리자의 정책에 따른 사용자들의 권한 부여로 유지됨

**무결성**

데이터 값의 정확성과 정밀성을 의미함. 갱신 뒤 정확한 데이터를 유지하는 것이 중요



**암호화 기법**

- 공통키 방식(대칭형 암호화 알고리즘): 송신자가 암호키로 암호화하면 수신자가 동일한 암호키로 복화하는 방식.
- 공개키 방식(비대칭형 암호화 알고리즘): 데이터를 암호문으로 변환할 때의 암호키와 암호문을 평문을 변환시킬 때의 복호키가 서로 다르며, 암호키는 공개하고 복호키는 비밀로 하여 보안을 유지하는 방법.



**트리거**

무결성 위반 시 트랜잭션을 취소하는 것에서 더 나아가 다른 조치를 명세하고자 할 때 사용하는 것으로, 메시지를 전달하거나 데이터를 자동으로 갱신할 수 있도록 함수나 명령을 수행하게 제약을 가하는 것.



### 병행제어

---

**로킹(Locking)**

하나의 트랜잭션이 어떤 데이터에 액세스 하는 동안 다른 트랜잭션이 접근하지못하도로록 Lock를 소유한 트랜잭션이 데이터에 접근하도록 로킹 규칙을 정해놓고 해결하는 방법 

- 교착상태의 위험이 있다. 

**로킹 단위**

- 작게 했을 때: 병행성은 높지만 관리가 어렵다. 
- 크게 했을 때: 병행성 수준은 낮아지지만 관리가 쉽다. 공유도가 현저히 떨어진다. 



### SQL

---

**join**

- left join



**SQL Injection**



**Statement vs PrepareStatement**



### NoSQL

---

**정의**

관계형 데이터 모델을 **지양** 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.

**CAP 이론**

- 일관성(Consistency)

일관성은 동시성 또는 동일성이라고도 하며 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미한다. 각 NoSQL 들은 분산 노드 간의 데이터 동기화를 위해서 두 가지 방법을 사용한다. 첫번째로 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법이 있다. 그만큼 느린 응답시간을 보이지만 데이터의 정합성을 보장한다. 두번째로 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법이 있다. 빠른 응답시간을 보인다는 장점이 있지만, 쓰기 노드에 장애가 발생하였을 경우 데이터가 손실될 수 있다.

- 가용성(Availability)

가용성이란 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것이며 내고장성이라고도 한다. 내고장성을 가진 NoSQL 은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능하다. 몇몇 NoSQL 은 가용성을 보장하기 위해 데이터 복제(Replication)을 사용한다. 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇 대의 노드가 고장나도 데이터가 유실되지 않도록 하는 방법이다. 데이터 중복 저장 방법에는 동일한 데이터를 가진 저장소를 하나 더 생성하는 Master-Slave 복제 방법과 데이터 단위로 중복 저장하는 Peer-to-Peer 복제 방법이 있다.

-  네트워크 분할 허용성(Partition tolerance)

분할 허용성이란 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함을 의미한다.



**저장 방식에 따른 NoSQL 분류**

- Key-Value Model

가장 기본적인 형태의 NoSQL 이며 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다. 단순한 저장구조로 인하여 복잡한 조회 연산을 지원하지 않는다. 또한 고속 읽기와 쓰기에 최적화된 경우가 많다. 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다.

- Document Model

키-값 모델을 개념적으로 확장한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다. 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사하다. 키는 문서에 대한 ID 로 표현된다. 또한 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID 에 대한 인덱스를 생성한다. 문서 ID 에 대한 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.

대부분의 문서 모델 NoSQL 은 B 트리 인덱스를 사용하여 2 차 인덱스를 생성한다. B 트리는 크기가 커지면 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 떨어지게 된다. 그렇기 때문에 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능을 보인다. 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용된다.
*ex) MongoDB*

- Column Model

하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다.

구글의 빅테이블이 대표적인 예로 차후 컬럼형 NoSQL 은 빅테이블의 영향을 받았다. 이러한 이유로 Row key, Column Key, Column Family 같은 빅테이블 개념이 공통적으로 사용된다. 저장의 기본 단위는 컬럼으로 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 이러한 컬럼들의 집하빙 로우(Row)이며, 로우키(Row key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.

대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.



#### RDBMS vs NOSQL



#### Optimazer



#### Replication





#### Partitioning





#### Sharding