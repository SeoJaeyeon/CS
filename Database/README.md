### Database

---

**목차**

- [데이터베이스의 정의](#데이터베이스의-정의)
- [DBMS vs 파일시스템](#dbms)
- [데이터 정규화](#데이터-정규화)
- [데이터베이스의 성능](#데이터베이스의-성능)
- [인덱스](#인덱스)
- [트랜잭션](#트랜잭션)
- [보안 및 무결성](#보안-및-무결성)
- [병행제어](#병행제어)
- [SQL](sql)
- [NoSQL](#nosql)

---

### 데이터베이스의 정의

---

- 응용 시스템들이 데이터를 공유할 수 있도록 모든 데이터를 통합하여 저장한 데이터 
- Shared Data, Operational Data, Integrated Data, Stored Data



### 데이터베이스의 특징

- 데이터 중복의 최소화
- 계속적인 변화: 항상 최신의 데이터 유지
- 실시간 접근
- 동시 공유
- 내용에 의한 접근: 저장되어 있는 데이터가 주소가 아닌 내용에 의해 참조될 수 있음
- 뛰어난 자료 간 연계성: 개체 사이의 관계성이 저장됨



### DBMS(Database Management System)

---

- 운영체제 위에서 작동하며 데이터베이스의 생성과 조작을 담당하는 소프트웨어 시스템

**DBMS의 필수 기능**

- **정의 기능**: 모든 응용프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 **데이터의 타입과 구조에 대한 정의, 이용방식, 제약 조건 등을 명시**하는 기능
- **조작 기능**: **검색, 갱신, 삽입, 삭제** 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단 제공
- **제어 기능**: 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 **데이터의 무결성**이 유지되도록 제어. 정당한 사용자가 허가된 데이터만 접근할 수 있도록 **보안을 유지하고 권한을 검사**. 여러 사용자가 데이터에 동시에 접근할 때 처리 결과가 항상 정확성을 유지하도록 **병행제어**가 가능해야 한다.



**DBMS의 특징**

- 데이터 중복의 최소화 -> 파일시스템의 단점
- 데이터 공유 
- 데이터 표준화
- 데이터 보안성 -> 계정 관리 또는 접근 권한 설정
- 데이터 무결성 -> 데이터의 유효성 검사를 통해 잘못된 데이터를 방지
- 데이터 일관성 -> 연관된 정보를 논리적 구조로 관리함으로 써, 데이터의 불일치성 배제



**파일시스템 vs DBMS**

- **데이터의 종속성**: <u>파일 시스템은 하나의 데이터 구조를 하나의 응용 프로그램이 독립적으로 관리</u>하기 때문에, 데이터 구조를 변경할 때 그 <u>응용 프로그램도 변경</u>해야하는 단점이 있다. 하지만 **DBMS에서는 프로그램과 데이터가 독립**되어있기 때문에 이러한 문제점을 피할 수 있다.
- **데이터의 중복성**: 파일 시스템은 같은 내용이더라도 구조가 다르면 중복되어 저장되기 때문에, 데이터의 일관성, 무결성, 보안에 좋지 않다. **DBMS는 데이터를 통합해서 관리함으로써 자료의 중복과 데이터의 중복성 문제를 해결**할 수 있다.



### 데이터 정규화

---

**이상(Anomaly) 현상**

데이터의 중복으로 인해 발생하는 이상현상 

- 삭제 이상: 임의의 튜플 삭제 시 그 튜플과 관계를 가지고 있던 관계성도 함께 삭제되는 현상
- 삽입 이상: 삽입 의도가 없는 관계도 삽입되는 현상(Null)
- 갱신 이상: 임의의 데이터를 갱신했을 때, 관계를 형성하던 다른 튜플과의 일관성이 깨지는 현상 



**함수 종속(FD: Functional Dependency)**

어떤 릴레이션 R에서 A, B가 릴레이션 R의 부분 속성이라고 할 때, 속성 A의 도메인 값 각각에 대해 속성 B의 도메인 값이 오직 한 개만 연관 된 경우 B는 A의 함수 종속이라고 하며, A -> B 라고 표현한다. A는 결정자, B는 종속자라고 한다. 



**정규화**

이상 현상이 발생하지 않도록 **하나의 릴레이션에 하나의 의미**만 존재하게 릴레이션을 분해하는 과정 

- 제 1정규형: 어떤 릴레이션 R에 속한 모든 도메인이 **원자 값**으로만 되어 있음
- 제 2정규형: 어떤 릴레이션 R이 제 1정규형에 속하고, 기본키에 속하지 않는 모든 속성이 기본키에 **완전 함수적 종속** 

- 제 3정규형: 어떤 릴레이션 R이 제 2정규형이면서, 기본키에 속하지 않는 모든 속성이 기본키에 **이행적 함수 종속이 아닌 경우**
- 보이스 코드 정규형(Boyce-Codd Normal Form: BCNF): 릴레이션 R의 모든 결정자가 후보키
- 제 4정규형: 릴레이션 R에서 A에 다중치 종속인 B가 존재할 때, R의 모든 속성도 A에 함수 종속 
- 제 5정규형: 릴레이션 R에 존재하는 모든 조인 종속이 릴레이션 R의 후보키를 통해서만 성립되는 경우



### 데이터베이스의 성능

---

출처 - https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database

데이터베이스의 성능 이슈는 디스크 I/O 를 어떻게 줄이느냐에서 시작된다. 디스크 I/O 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.

그렇기 때문에 순차 I/O 가 랜덤 I/O 보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O 이다. 랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.



### 인덱스

---

**인덱스(Index)**

신속한 검색을 위해 데이터의 **위치 정보**를 모아놓은 것으로 책에서 목차에 해당

- DBMS에서 **칼럼의 값**과 해당 레코드가 **저장된 주소**를 K-V 쌍의 인덱스로 만들어둔다.
- 항상 **정렬된 상태**를 유지하기 때문에 <u>검색은 빠르지만, 삽입, 삭제 연산의 속도는 느리다.</u>



**인덱스 자료구조**

- **B-트리**: **모든 인덱스 값이 실제 데이터**를 가리키도록 구성되어 있으며 탐색 시 **중위순회** 한다. 한 노드 안에 있는 키 값은 **오름차순 정렬**되어있으며, 키 값의 삽입, 삭제 시 자동으로 합병이나 분할이 이루어진다.
- **B+-트리**: **인덱스 세트와 순차 세트**로 구성하여 인덱스 세트는 리프노드를 찾아갈 수 있는 키, 포인터만 제공하고, 리프 노드에 모든 데이터가 나타나도록 하여 **리프 노드만으로도 모든 데이터를 탐색할 수 있도록 한 구조**이다. 리프노드는 순차 세트를 나타내며 모두 리스트로 연결되어 있고 **정렬**되어있다. 대부분의 **DBMS가 B+-트리 인덱스**를 사용한다.
- **Red-Black Tree**: 각각의 노드가 레드나 블랙인 색상 속성을 가지고 있는 **이진 탐색 트리**로, 자료의 삽입과 삭제, 검색에서 최악의 경우에도 **일정한 실행 시간을 보장** (worst-case guarantees)한다. 루트 노드부터 가장 먼 경로까지의 거리가, 가장 가까운 경로까지의 거리의 두 배 보다 항상 작은 것이 특징이다.
- **클러스터드 인덱스**: **프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것**을 클러스터드 인덱스라고 표현한다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다(정렬 유지). 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야 한다.**클러스터드 인덱스는 테이블 당 한 개만 생성**할 수 있다. 
- **논-클러스터드 인덱스**: 클러스터드 인덱스와 다르게 물리적으로 행을 재배열하지 않는다. 또, 1개 이상으로 생성할 수 있다. 별도의 인덱스 테이블을 생성하여 정렬하는 방식으로 컬럼을 찾는다. 



### 트랜잭션

---

**트랜잭션의 정의**

작업의 완전성을 보장하기 위해 논리적인 작업 셋을 모두 처리하거나, 모두 처리하지 않는 기능



**트랜잭션의 특성(ACID)**

- **원자성(Atomicity)**
- **일관성(Consistency):** 트랜잭션 실행 후에도 데이터베이스는 무결성이 유지되어야 함
- **독립성(Isolation)**: 트랜잭션 실행 중 다른 트랜잭션이 침범하지 못함
- **영속성(Durability)**: 트랜잭션에 의해 변화된 상태는 계속 유지될 수 있어야 함 



**트랜잭션의 연산**

- **COMMIT**: 트랜잭션의 실행이 성공적으로 종료됨. **영속성과 일관성**이 보장된 상태.
- **ROLLBACK**: 트랜잭션이 실패하고 **원래의 상태로 복귀**시켜야 하는 상태 



**격리성 관련 문제점**

- **Dirty Read**: 한 트랜잭션이 데이터에 접근하여 값을 A에서 B로 변경했고 아직 **커밋**하지 않았을 때 다른 트랜잭션이 해당 데이터를 Read하면 B로 읽게된다. 이 때, 트랜잭션이 커밋을 완료하지 않는다면 데이터 불일치성이 발생한다. *Read Committed (level 1)으로 해결 가능*

- **Non-Repeatable Read**: 한 트랜잭션이 데이터를 READ 하고 있을 때, 다른 트랜잭션이 해당 데이터에 접근하여 값을 변경 또는 삭제하고 커밋을 하면, **기존 트랜잭션이 다시 READ할 때 해당 변경되거나 삭제된 데이터를 찾게 된다.** *Repeatable Read(level 2)로 해결 가능*

  -> 한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때 

- **Phantom Read**: 트랜잭션 중에 특정 조건으로 데이터를 검색하여 결과를 얻은 경우, 다른 트랜잭션이 해당 조건의 데이터 일부를 삭제 또는 추가 했을 때 아직 끝나지 않은 첫 트랜잭션이 다시 데이터를 같은 조건으로 조회하면 **두 번째 트랜잭션에서 추가/삭제 된 데이터가 함께 조회/누락된다.** 만약 연산이 **롤백**되면 데이터가 불일치성이 발생한다. *Serializable (level3) 으로 해결 가능*

  -> 한 트랜잭션 내에서 일정 범위의 레코드를 두 번 이상 읽을 때



**트랜잭션의 격리수준(Isolation Level)**

- **Serializable**: 가장 엄격한 격리 수준. 동시 처리 성능이 급격히 떨어질 수 있다.
- **Repeatable Read**: 트랜잭션 내에서 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. Phantom Read 발생 가능.
- **Read Committed**: 커밋이 완료된 데이터만 읽을 수 있다. Non-Repeatable Read, Phantom Read 발생 가능.
- **Read Uncommitted**: 한 트랜잭션에서 커밋하지 않은 데이터에 다른 트랜잭션이 접근 가능하다. 격리성 관련 모든 문제가 발생할 수 있지만 동시 처리 성능이 가장 높다.



### 보안 및 무결성

---

**보안**

외부의 부적절한 접근으로부터 보호하는 것으로 관리자의 정책에 따른 사용자들의 권한 부여로 유지됨

**무결성**

데이터 값의 정확성과 정밀성을 의미함. 갱신 뒤 정확한 데이터를 유지하는 것이 중요



**암호화 기법**

- **공통키 방식(대칭형 암호화 알고리즘)**: 송신자가 암호키로 암호화하면 수신자가 동일한 암호키로 복화하는 방식.
- **공개키 방식(비대칭형 암호화 알고리즘)**: 데이터를 암호문으로 변환할 때의 암호키와 암호문을 평문을 변환시킬 때의 복호키가 서로 다르며, 암호키는 공개하고 복호키는 비밀로 하여 보안을 유지하는 방법.



**트리거**

무결성 위반 시 트랜잭션을 취소하는 것에서 더 나아가 다른 조치를 명세하고자 할 때 사용하는 것으로, 메시지를 전달하거나 데이터를 자동으로 갱신할 수 있도록 함수나 명령을 수행하게 제약을 가하는 것.



### 병행제어

---

**로킹(Locking)**

하나의 트랜잭션이 어떤 데이터에 액세스 하는 동안 다른 트랜잭션이 접근하지못하도로록 Lock를 소유한 트랜잭션이 데이터에 접근하도록 로킹 규칙을 정해놓고 해결하는 방법 

- 교착상태의 위험이 있다. 

**로킹 단위**

- 작게 했을 때: 병행성은 높지만 관리가 어렵다. 
- 크게 했을 때: 병행성 수준은 낮아지지만 관리가 쉽다. 공유도가 현저히 떨어진다. 



### SQL

---

**join**

- join: 교집합
- left join: 왼쪽 테이블을 중심으로 오른쪽 테이블 매치. 왼쪽 테이블 한 개의 레코드에 여러 개의 오른쪽 테이블 레코드가 일치할 경우, 해당 왼쪽 레코드를 여러번 표시하게 된다. 매치되는 오른쪽 테이블 레코드가 없으면 NULL을 표시한다.



**SQL Injection**

응용 프로그램 보안 상의 허점을 의도적으로 이용해 **악의적인 SQL문이 실행되게 함**으로써 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 방법



**Statement vs PrepareStatement**

- Statement: **정적 SQL문**을 실행해 작성된 결과를 돌려주기 위해 사용되는 객체로, Statement 객체마다 1개의 ResultSet객체만 동시에 오픈할 수 있다. 

- PrepareStatement: SQL 문은 프리컴파일되어 PrepareStatement에 포함된다. 이 문장을 여러차례 효율적으로 실행하는 목적으로 사용할 수 있다.


### NoSQL

---

**정의**

관계형 데이터 모델을 **지양**하고 대량의 분산된 데이터를 저장하고 조회하는데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다. 핵심은 **Horizontal Scalability**와 **High Acailability**이다.

**특징**

- 거대한 Map으로 K-V 형식 지원
- 관계를 정의하지 않음
- 대용량 데이터 저장
- 분산형 구조를 통해 여러 대의 서버에 분산하여 저장하고 상호복제하여 데이터 유실이나 서비스 중지에 대비
- 읽기 작업보다 쓰기 작업이 더 빠르며 일반적으로 RDBMS에 비해 쓰기와 읽기 성능이 빠름

*cf) RDBMS의 한계*

*많은 데이터량과 데이터 처리량이 계속적으로 증가한다면,*

*1) 스키마 문제: 빅데이터를 RDB스키마에 맞춰 변경해서 넣으려면 매우 긴 시간의 down time 발생*

*2) 스케일업의 한계: RDBMS는 애초부터 스케일 아웃을 염두하고 설계되지 않음.*

**CAP 이론**

- **일관성(Consistency)**

일관성은 동시성 또는 동일성이라고도 하며 **다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증**하는 것을 의미한다. 각 NoSQL 들은 분산 노드 간의 데이터 동기화를 위해서 두 가지 방법을 사용한다. 첫번째로 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 **동기식 방법**이 있다. 그만큼 <u>느린 응답시간을 보이지만 데이터의 정합성을 보장</u>한다. 두번째로 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 **비동기식 방법**이 있다. <u>빠른 응답시간을 보인다는 장점이 있지만, 쓰기 노드에 장애가 발생하였을 경우 데이터가 손실</u>될 수 있다.

- **가용성(Availability)**

가용성이란 모든 클라이언트의 읽기와 쓰기 요청에 대하여 **항상 응답이 가능해야 함**을 보증하는 것이며 내고장성이라고도 한다. 내고장성을 가진 NoSQL 은 클러스터 내에서 **몇 개의 노드가 망가지더라도 정상적인 서비스가 가능**하다. 몇몇 NoSQL 은 가용성을 보장하기 위해 <u>데이터 복제(Replication)</u>을 사용한다. 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇 대의 노드가 고장나도 데이터가 유실되지 않도록 하는 방법이다. 데이터 중복 저장 방법에는 동일한 데이터를 가진 저장소를 하나 더 생성하는 <u>Master-Slave</u> 복제 방법과 데이터 단위로 중복 저장하는 <u>Peer-to-Peer</u> 복제 방법이 있다.

-  **네트워크 분할 허용성(Partition tolerance)**

분할 허용성이란 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 **네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함**을 의미한다.



**저장 방식에 따른 NoSQL 분류**

- **Key-Value Model**

가장 기본적인 형태의 NoSQL이며 키 하나로 데이터 하나를 저장하고 조회할 수 있는 **단일 키-값 구조**를 갖는다. 단순한 저장구조로 인하여 **복잡한 조회 연산을 지원하지 않는다.** 또한 **고속 읽기와 쓰기**에 최적화된 경우가 많다. 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 **데이터 정합성을 보장할 수 없다.**

*ex) Redis, Oracle Coherence*

- **Document Model**

키-값 모델을 개념적으로 확장한 구조로 **하나의 키에 하나의 구조화된 문서(JSON, XML, YAML)를 저장하고 조회**한다. 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사하다. 키는 문서에 대한 ID 로 표현된다. 또한 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID 에 대한 인덱스를 생성한다. 문서 ID 에 대한 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.

대부분의 문서 모델 NoSQL 은 B 트리 인덱스를 사용하여 2 차 인덱스를 생성한다. B 트리는 크기가 커지면 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 떨어지게 된다. 그렇기 때문에 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능을 보인다. 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용된다.
*ex) MongoDB, Couch DB, Riak*

- **Column Model(=Big Table Model)**

**하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다.** 일반적은 NoSQL과 달리 정렬기능을 제공하는 것이 특징이다.

구글의 빅테이블이 대표적인 예로 차후 컬럼형 NoSQL 은 빅테이블의 영향을 받았다. 이러한 이유로 Row key, Column Key, Column Family 같은 빅테이블 개념이 공통적으로 사용된다. 저장의 기본 단위는 컬럼으로 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 이러한 컬럼들의 집하빙 로우(Row)이며, 로우키(Row key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.

대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.

*ex) Cassamdra, Hbase*

- **Graph Model**

  모든 노드들이 끊이지 않고 연결되어있다. node와 relationship으로 구성되어있으며, relationship은 보통 양적인 속성을 가진다.

*ex) Sones, AllehroGraph, neo4j* 



#### RDBMS vs NOSQL

|      | RDBMS                                                        | NoSQL                                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 장점 | ACID 트랜잭션을 사용하기 쉬운 개발 방식 사용/ 뷰를 사용한 컬럼과 로우에 대한 보안 설정은 인가받지 않은 사용자들로부터의 조회나 변경을 막음/ 대부분의 SQL코드는 오픈 소스를 포함한 다른 SQL DB로의 포팅이 가능/ 유효성 검사를 통한 품질 향상 가능 | 테스트 데이터 조회가 ER모델링이 완료되기 이전에 드롭 앤 드랍 도구를 사용해서 가능함/ 컴포넌트 형태로 서로 교환될 수 있는 모듈화된 아키텍처 제공/ 수평 확장 가능/ 자동 샤딩 기술에 대해 적은 운영 비용 발생/ 통합된 검색 기능은 고품질의 랭킹 검색 결과 제공/ 다양한 가변성이 있는 데이터 저장 쉬움 |
| 단점 | 객체-관계형 매핑 레이어가 복잡할 수 있음/ ER 모델링이 필요함/ 시스템 조인이 필요한 경우 확장성을 제약함/ 전체 문서에 대한 검색은 별도의 도구가 필요함/ 테이블에 다양한 가변성이 있는 데이터를 저장하기 어려움 | ACID 트랜잭션은 데이터베이스 수준의 문서 내에서만 작동함/ 세밀한 보안을 제공하지 않음/ 표준화되지 않은 쿼리 언어를 사용하며 이식성을 방해함 |



#### SQL Optimazer

SQL을 위한 최적의 실행계획을 생성하는 알고리즘

- Rule Base: SQL syntax 및 Index의 존재 유무 등을 확인하여 실행 계획 생성. 

  ROWID -> Unique Index, Index, FullScan

- Cost Base: 비용을 산정해서 실행 계획 생성

#### DB Replication

두 개 이상의 DBMS 시스템을 Master/ Slave로 나눠서 동일한 데이터를 저장하는 방식으로 Master DBMS에는 데이터의 수정사항만 반영하고 replication하여 Slave DBMS에 실제 데이터를 복사한다. 



#### DB Partitioning

큰 table이나 인덱스를 관리하기 쉬운 단위로 분리하는 방법

- 장점: 가용성/ 관리용이성/ 성능
- 단점: join에 대한 비용 증가/ 테이블과 인덱스를 함께 partitioning 해야 함



#### Sharding

같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법(=horozpmtal partitioning)

- 프로그래밍, 운영적 복잡도가 더 높아지기 때문에 가능한 피해야함 
- 대체방법: Scale-in(Upgrade Hardware Spec), Cache나 Replication, Vertically Partitioning